# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.4
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package libstdf;
use base qw(Exporter);
use base qw(DynaLoader);
package libstdfc;
bootstrap libstdf;
package libstdf;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package libstdf;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package libstdf;

*cdata = *libstdfc::cdata;
*memmove = *libstdfc::memmove;
*stdf_version = *libstdfc::stdf_version;
*rec_to_mir = *libstdfc::rec_to_mir;
*rec_to_sdr = *libstdfc::rec_to_sdr;
*rec_to_pcr = *libstdfc::rec_to_pcr;
*rec_to_mrr = *libstdfc::rec_to_mrr;
*rec_to_wir = *libstdfc::rec_to_wir;
*rec_to_pir = *libstdfc::rec_to_pir;
*rec_to_prr = *libstdfc::rec_to_prr;
*rec_to_ptr = *libstdfc::rec_to_ptr;
*rec_to_dtr = *libstdfc::rec_to_dtr;
*rec_to_atr = *libstdfc::rec_to_atr;
*rec_to_far = *libstdfc::rec_to_far;
*rec_to_hbr = *libstdfc::rec_to_hbr;
*rec_to_sbr = *libstdfc::rec_to_sbr;
*rec_to_pmr = *libstdfc::rec_to_pmr;
*rec_to_pgr = *libstdfc::rec_to_pgr;
*rec_to_plr = *libstdfc::rec_to_plr;
*rec_to_rdr = *libstdfc::rec_to_rdr;
*rec_to_wrr = *libstdfc::rec_to_wrr;
*rec_to_wcr = *libstdfc::rec_to_wcr;
*rec_to_tsr = *libstdfc::rec_to_tsr;
*rec_to_mpr = *libstdfc::rec_to_mpr;
*rec_to_ftr = *libstdfc::rec_to_ftr;
*rec_to_bps = *libstdfc::rec_to_bps;
*rec_to_eps = *libstdfc::rec_to_eps;
*rec_to_gdr = *libstdfc::rec_to_gdr;
*rec_to_unknown = *libstdfc::rec_to_unknown;
*read_record = *libstdfc::read_record;
*free_record = *libstdfc::free_record;
*get_rec_name = *libstdfc::get_rec_name;
*make_rec = *libstdfc::make_rec;
*init_header = *libstdfc::init_header;
*xU1_to_RV = *libstdfc::xU1_to_RV;
*xN1_to_RV = *libstdfc::xN1_to_RV;
*xU2_to_RV = *libstdfc::xU2_to_RV;
*xR4_to_RV = *libstdfc::xR4_to_RV;
*xCn_to_RV = *libstdfc::xCn_to_RV;
*stdf_open = *libstdfc::stdf_open;
*stdf_close = *libstdfc::stdf_close;
*stdf_read_record = *libstdfc::stdf_read_record;
*stdf_get_rec_name = *libstdfc::stdf_get_rec_name;
*stdf_free_record = *libstdfc::stdf_free_record;
*stdf_open_ex = *libstdfc::stdf_open_ex;
*stdf_read_record_raw = *libstdfc::stdf_read_record_raw;
*stdf_parse_raw_record = *libstdfc::stdf_parse_raw_record;
*stdf_write_record = *libstdfc::stdf_write_record;

############# Class : libstdf::dtc_Vn_ele ##############

package libstdf::dtc_Vn_ele;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libstdf );
%OWNER = ();
%ITERATORS = ();
*swig_type_get = *libstdfc::dtc_Vn_ele_type_get;
*swig_type_set = *libstdfc::dtc_Vn_ele_type_set;
*swig_data_get = *libstdfc::dtc_Vn_ele_data_get;
*swig_data_set = *libstdfc::dtc_Vn_ele_data_set;
sub new {
    my $pkg = shift;
    my $self = libstdfc::new_dtc_Vn_ele(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libstdfc::delete_dtc_Vn_ele($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libstdf::rec_header ##############

package libstdf::rec_header;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libstdf );
%OWNER = ();
%ITERATORS = ();
*swig_stdf_file_get = *libstdfc::rec_header_stdf_file_get;
*swig_stdf_file_set = *libstdfc::rec_header_stdf_file_set;
*swig_state_get = *libstdfc::rec_header_state_get;
*swig_state_set = *libstdfc::rec_header_state_set;
*swig_REC_LEN_get = *libstdfc::rec_header_REC_LEN_get;
*swig_REC_LEN_set = *libstdfc::rec_header_REC_LEN_set;
*swig_REC_TYP_get = *libstdfc::rec_header_REC_TYP_get;
*swig_REC_TYP_set = *libstdfc::rec_header_REC_TYP_set;
*swig_REC_SUB_get = *libstdfc::rec_header_REC_SUB_get;
*swig_REC_SUB_set = *libstdfc::rec_header_REC_SUB_set;
sub new {
    my $pkg = shift;
    my $self = libstdfc::new_rec_header(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libstdfc::delete_rec_header($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libstdf::rec_unknown ##############

package libstdf::rec_unknown;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libstdf );
%OWNER = ();
%ITERATORS = ();
*swig_header_get = *libstdfc::rec_unknown_header_get;
*swig_header_set = *libstdfc::rec_unknown_header_set;
*swig_data_get = *libstdfc::rec_unknown_data_get;
*swig_data_set = *libstdfc::rec_unknown_data_set;
sub new {
    my $pkg = shift;
    my $self = libstdfc::new_rec_unknown(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libstdfc::delete_rec_unknown($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libstdf::rec_far ##############

package libstdf::rec_far;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libstdf );
%OWNER = ();
%ITERATORS = ();
*swig_header_get = *libstdfc::rec_far_header_get;
*swig_header_set = *libstdfc::rec_far_header_set;
*swig_CPU_TYPE_get = *libstdfc::rec_far_CPU_TYPE_get;
*swig_CPU_TYPE_set = *libstdfc::rec_far_CPU_TYPE_set;
*swig_STDF_VER_get = *libstdfc::rec_far_STDF_VER_get;
*swig_STDF_VER_set = *libstdfc::rec_far_STDF_VER_set;
sub new {
    my $pkg = shift;
    my $self = libstdfc::new_rec_far(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libstdfc::delete_rec_far($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libstdf::rec_atr ##############

package libstdf::rec_atr;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libstdf );
%OWNER = ();
%ITERATORS = ();
*swig_header_get = *libstdfc::rec_atr_header_get;
*swig_header_set = *libstdfc::rec_atr_header_set;
*swig_MOD_TIM_get = *libstdfc::rec_atr_MOD_TIM_get;
*swig_MOD_TIM_set = *libstdfc::rec_atr_MOD_TIM_set;
*swig_CMD_LINE_get = *libstdfc::rec_atr_CMD_LINE_get;
*swig_CMD_LINE_set = *libstdfc::rec_atr_CMD_LINE_set;
sub new {
    my $pkg = shift;
    my $self = libstdfc::new_rec_atr(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libstdfc::delete_rec_atr($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libstdf::rec_mir ##############

package libstdf::rec_mir;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libstdf );
%OWNER = ();
%ITERATORS = ();
*swig_header_get = *libstdfc::rec_mir_header_get;
*swig_header_set = *libstdfc::rec_mir_header_set;
*swig_SETUP_T_get = *libstdfc::rec_mir_SETUP_T_get;
*swig_SETUP_T_set = *libstdfc::rec_mir_SETUP_T_set;
*swig_START_T_get = *libstdfc::rec_mir_START_T_get;
*swig_START_T_set = *libstdfc::rec_mir_START_T_set;
*swig_STAT_NUM_get = *libstdfc::rec_mir_STAT_NUM_get;
*swig_STAT_NUM_set = *libstdfc::rec_mir_STAT_NUM_set;
*swig_MODE_COD_get = *libstdfc::rec_mir_MODE_COD_get;
*swig_MODE_COD_set = *libstdfc::rec_mir_MODE_COD_set;
*swig_RTST_COD_get = *libstdfc::rec_mir_RTST_COD_get;
*swig_RTST_COD_set = *libstdfc::rec_mir_RTST_COD_set;
*swig_PROT_COD_get = *libstdfc::rec_mir_PROT_COD_get;
*swig_PROT_COD_set = *libstdfc::rec_mir_PROT_COD_set;
*swig_BURN_TIM_get = *libstdfc::rec_mir_BURN_TIM_get;
*swig_BURN_TIM_set = *libstdfc::rec_mir_BURN_TIM_set;
*swig_CMOD_COD_get = *libstdfc::rec_mir_CMOD_COD_get;
*swig_CMOD_COD_set = *libstdfc::rec_mir_CMOD_COD_set;
*swig_LOT_ID_get = *libstdfc::rec_mir_LOT_ID_get;
*swig_LOT_ID_set = *libstdfc::rec_mir_LOT_ID_set;
*swig_PART_TYP_get = *libstdfc::rec_mir_PART_TYP_get;
*swig_PART_TYP_set = *libstdfc::rec_mir_PART_TYP_set;
*swig_NODE_NAM_get = *libstdfc::rec_mir_NODE_NAM_get;
*swig_NODE_NAM_set = *libstdfc::rec_mir_NODE_NAM_set;
*swig_TSTR_TYP_get = *libstdfc::rec_mir_TSTR_TYP_get;
*swig_TSTR_TYP_set = *libstdfc::rec_mir_TSTR_TYP_set;
*swig_JOB_NAM_get = *libstdfc::rec_mir_JOB_NAM_get;
*swig_JOB_NAM_set = *libstdfc::rec_mir_JOB_NAM_set;
*swig_JOB_REV_get = *libstdfc::rec_mir_JOB_REV_get;
*swig_JOB_REV_set = *libstdfc::rec_mir_JOB_REV_set;
*swig_SBLOT_ID_get = *libstdfc::rec_mir_SBLOT_ID_get;
*swig_SBLOT_ID_set = *libstdfc::rec_mir_SBLOT_ID_set;
*swig_OPER_NAM_get = *libstdfc::rec_mir_OPER_NAM_get;
*swig_OPER_NAM_set = *libstdfc::rec_mir_OPER_NAM_set;
*swig_EXEC_TYP_get = *libstdfc::rec_mir_EXEC_TYP_get;
*swig_EXEC_TYP_set = *libstdfc::rec_mir_EXEC_TYP_set;
*swig_EXEC_VER_get = *libstdfc::rec_mir_EXEC_VER_get;
*swig_EXEC_VER_set = *libstdfc::rec_mir_EXEC_VER_set;
*swig_TEST_COD_get = *libstdfc::rec_mir_TEST_COD_get;
*swig_TEST_COD_set = *libstdfc::rec_mir_TEST_COD_set;
*swig_TST_TEMP_get = *libstdfc::rec_mir_TST_TEMP_get;
*swig_TST_TEMP_set = *libstdfc::rec_mir_TST_TEMP_set;
*swig_USER_TXT_get = *libstdfc::rec_mir_USER_TXT_get;
*swig_USER_TXT_set = *libstdfc::rec_mir_USER_TXT_set;
*swig_AUX_FILE_get = *libstdfc::rec_mir_AUX_FILE_get;
*swig_AUX_FILE_set = *libstdfc::rec_mir_AUX_FILE_set;
*swig_PKG_TYP_get = *libstdfc::rec_mir_PKG_TYP_get;
*swig_PKG_TYP_set = *libstdfc::rec_mir_PKG_TYP_set;
*swig_FAMILY_ID_get = *libstdfc::rec_mir_FAMILY_ID_get;
*swig_FAMILY_ID_set = *libstdfc::rec_mir_FAMILY_ID_set;
*swig_DATE_COD_get = *libstdfc::rec_mir_DATE_COD_get;
*swig_DATE_COD_set = *libstdfc::rec_mir_DATE_COD_set;
*swig_FACIL_ID_get = *libstdfc::rec_mir_FACIL_ID_get;
*swig_FACIL_ID_set = *libstdfc::rec_mir_FACIL_ID_set;
*swig_FLOOR_ID_get = *libstdfc::rec_mir_FLOOR_ID_get;
*swig_FLOOR_ID_set = *libstdfc::rec_mir_FLOOR_ID_set;
*swig_PROC_ID_get = *libstdfc::rec_mir_PROC_ID_get;
*swig_PROC_ID_set = *libstdfc::rec_mir_PROC_ID_set;
*swig_OPER_FRQ_get = *libstdfc::rec_mir_OPER_FRQ_get;
*swig_OPER_FRQ_set = *libstdfc::rec_mir_OPER_FRQ_set;
*swig_SPEC_NAM_get = *libstdfc::rec_mir_SPEC_NAM_get;
*swig_SPEC_NAM_set = *libstdfc::rec_mir_SPEC_NAM_set;
*swig_SPEC_VER_get = *libstdfc::rec_mir_SPEC_VER_get;
*swig_SPEC_VER_set = *libstdfc::rec_mir_SPEC_VER_set;
*swig_FLOW_ID_get = *libstdfc::rec_mir_FLOW_ID_get;
*swig_FLOW_ID_set = *libstdfc::rec_mir_FLOW_ID_set;
*swig_SETUP_ID_get = *libstdfc::rec_mir_SETUP_ID_get;
*swig_SETUP_ID_set = *libstdfc::rec_mir_SETUP_ID_set;
*swig_DSGN_REV_get = *libstdfc::rec_mir_DSGN_REV_get;
*swig_DSGN_REV_set = *libstdfc::rec_mir_DSGN_REV_set;
*swig_ENG_ID_get = *libstdfc::rec_mir_ENG_ID_get;
*swig_ENG_ID_set = *libstdfc::rec_mir_ENG_ID_set;
*swig_ROM_COD_get = *libstdfc::rec_mir_ROM_COD_get;
*swig_ROM_COD_set = *libstdfc::rec_mir_ROM_COD_set;
*swig_SERL_NUM_get = *libstdfc::rec_mir_SERL_NUM_get;
*swig_SERL_NUM_set = *libstdfc::rec_mir_SERL_NUM_set;
*swig_SUPR_NAM_get = *libstdfc::rec_mir_SUPR_NAM_get;
*swig_SUPR_NAM_set = *libstdfc::rec_mir_SUPR_NAM_set;
sub new {
    my $pkg = shift;
    my $self = libstdfc::new_rec_mir(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libstdfc::delete_rec_mir($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libstdf::rec_mrr ##############

package libstdf::rec_mrr;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libstdf );
%OWNER = ();
%ITERATORS = ();
*swig_header_get = *libstdfc::rec_mrr_header_get;
*swig_header_set = *libstdfc::rec_mrr_header_set;
*swig_FINISH_T_get = *libstdfc::rec_mrr_FINISH_T_get;
*swig_FINISH_T_set = *libstdfc::rec_mrr_FINISH_T_set;
*swig_DISP_COD_get = *libstdfc::rec_mrr_DISP_COD_get;
*swig_DISP_COD_set = *libstdfc::rec_mrr_DISP_COD_set;
*swig_USR_DESC_get = *libstdfc::rec_mrr_USR_DESC_get;
*swig_USR_DESC_set = *libstdfc::rec_mrr_USR_DESC_set;
*swig_EXC_DESC_get = *libstdfc::rec_mrr_EXC_DESC_get;
*swig_EXC_DESC_set = *libstdfc::rec_mrr_EXC_DESC_set;
sub new {
    my $pkg = shift;
    my $self = libstdfc::new_rec_mrr(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libstdfc::delete_rec_mrr($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libstdf::rec_pcr ##############

package libstdf::rec_pcr;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libstdf );
%OWNER = ();
%ITERATORS = ();
*swig_header_get = *libstdfc::rec_pcr_header_get;
*swig_header_set = *libstdfc::rec_pcr_header_set;
*swig_HEAD_NUM_get = *libstdfc::rec_pcr_HEAD_NUM_get;
*swig_HEAD_NUM_set = *libstdfc::rec_pcr_HEAD_NUM_set;
*swig_SITE_NUM_get = *libstdfc::rec_pcr_SITE_NUM_get;
*swig_SITE_NUM_set = *libstdfc::rec_pcr_SITE_NUM_set;
*swig_PART_CNT_get = *libstdfc::rec_pcr_PART_CNT_get;
*swig_PART_CNT_set = *libstdfc::rec_pcr_PART_CNT_set;
*swig_RTST_CNT_get = *libstdfc::rec_pcr_RTST_CNT_get;
*swig_RTST_CNT_set = *libstdfc::rec_pcr_RTST_CNT_set;
*swig_ABRT_CNT_get = *libstdfc::rec_pcr_ABRT_CNT_get;
*swig_ABRT_CNT_set = *libstdfc::rec_pcr_ABRT_CNT_set;
*swig_GOOD_CNT_get = *libstdfc::rec_pcr_GOOD_CNT_get;
*swig_GOOD_CNT_set = *libstdfc::rec_pcr_GOOD_CNT_set;
*swig_FUNC_CNT_get = *libstdfc::rec_pcr_FUNC_CNT_get;
*swig_FUNC_CNT_set = *libstdfc::rec_pcr_FUNC_CNT_set;
sub new {
    my $pkg = shift;
    my $self = libstdfc::new_rec_pcr(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libstdfc::delete_rec_pcr($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libstdf::rec_hbr ##############

package libstdf::rec_hbr;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libstdf );
%OWNER = ();
%ITERATORS = ();
*swig_header_get = *libstdfc::rec_hbr_header_get;
*swig_header_set = *libstdfc::rec_hbr_header_set;
*swig_HEAD_NUM_get = *libstdfc::rec_hbr_HEAD_NUM_get;
*swig_HEAD_NUM_set = *libstdfc::rec_hbr_HEAD_NUM_set;
*swig_SITE_NUM_get = *libstdfc::rec_hbr_SITE_NUM_get;
*swig_SITE_NUM_set = *libstdfc::rec_hbr_SITE_NUM_set;
*swig_HBIN_NUM_get = *libstdfc::rec_hbr_HBIN_NUM_get;
*swig_HBIN_NUM_set = *libstdfc::rec_hbr_HBIN_NUM_set;
*swig_HBIN_CNT_get = *libstdfc::rec_hbr_HBIN_CNT_get;
*swig_HBIN_CNT_set = *libstdfc::rec_hbr_HBIN_CNT_set;
*swig_HBIN_PF_get = *libstdfc::rec_hbr_HBIN_PF_get;
*swig_HBIN_PF_set = *libstdfc::rec_hbr_HBIN_PF_set;
*swig_HBIN_NAM_get = *libstdfc::rec_hbr_HBIN_NAM_get;
*swig_HBIN_NAM_set = *libstdfc::rec_hbr_HBIN_NAM_set;
sub new {
    my $pkg = shift;
    my $self = libstdfc::new_rec_hbr(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libstdfc::delete_rec_hbr($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libstdf::rec_sbr ##############

package libstdf::rec_sbr;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libstdf );
%OWNER = ();
%ITERATORS = ();
*swig_header_get = *libstdfc::rec_sbr_header_get;
*swig_header_set = *libstdfc::rec_sbr_header_set;
*swig_HEAD_NUM_get = *libstdfc::rec_sbr_HEAD_NUM_get;
*swig_HEAD_NUM_set = *libstdfc::rec_sbr_HEAD_NUM_set;
*swig_SITE_NUM_get = *libstdfc::rec_sbr_SITE_NUM_get;
*swig_SITE_NUM_set = *libstdfc::rec_sbr_SITE_NUM_set;
*swig_SBIN_NUM_get = *libstdfc::rec_sbr_SBIN_NUM_get;
*swig_SBIN_NUM_set = *libstdfc::rec_sbr_SBIN_NUM_set;
*swig_SBIN_CNT_get = *libstdfc::rec_sbr_SBIN_CNT_get;
*swig_SBIN_CNT_set = *libstdfc::rec_sbr_SBIN_CNT_set;
*swig_SBIN_PF_get = *libstdfc::rec_sbr_SBIN_PF_get;
*swig_SBIN_PF_set = *libstdfc::rec_sbr_SBIN_PF_set;
*swig_SBIN_NAM_get = *libstdfc::rec_sbr_SBIN_NAM_get;
*swig_SBIN_NAM_set = *libstdfc::rec_sbr_SBIN_NAM_set;
sub new {
    my $pkg = shift;
    my $self = libstdfc::new_rec_sbr(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libstdfc::delete_rec_sbr($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libstdf::rec_pmr ##############

package libstdf::rec_pmr;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libstdf );
%OWNER = ();
%ITERATORS = ();
*swig_header_get = *libstdfc::rec_pmr_header_get;
*swig_header_set = *libstdfc::rec_pmr_header_set;
*swig_PMR_INDX_get = *libstdfc::rec_pmr_PMR_INDX_get;
*swig_PMR_INDX_set = *libstdfc::rec_pmr_PMR_INDX_set;
*swig_CHAN_TYP_get = *libstdfc::rec_pmr_CHAN_TYP_get;
*swig_CHAN_TYP_set = *libstdfc::rec_pmr_CHAN_TYP_set;
*swig_CHAN_NAM_get = *libstdfc::rec_pmr_CHAN_NAM_get;
*swig_CHAN_NAM_set = *libstdfc::rec_pmr_CHAN_NAM_set;
*swig_PHY_NAM_get = *libstdfc::rec_pmr_PHY_NAM_get;
*swig_PHY_NAM_set = *libstdfc::rec_pmr_PHY_NAM_set;
*swig_LOG_NAM_get = *libstdfc::rec_pmr_LOG_NAM_get;
*swig_LOG_NAM_set = *libstdfc::rec_pmr_LOG_NAM_set;
*swig_HEAD_NUM_get = *libstdfc::rec_pmr_HEAD_NUM_get;
*swig_HEAD_NUM_set = *libstdfc::rec_pmr_HEAD_NUM_set;
*swig_SITE_NUM_get = *libstdfc::rec_pmr_SITE_NUM_get;
*swig_SITE_NUM_set = *libstdfc::rec_pmr_SITE_NUM_set;
sub new {
    my $pkg = shift;
    my $self = libstdfc::new_rec_pmr(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libstdfc::delete_rec_pmr($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libstdf::rec_pgr ##############

package libstdf::rec_pgr;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libstdf );
%OWNER = ();
%ITERATORS = ();
*swig_header_get = *libstdfc::rec_pgr_header_get;
*swig_header_set = *libstdfc::rec_pgr_header_set;
*swig_GRP_INDX_get = *libstdfc::rec_pgr_GRP_INDX_get;
*swig_GRP_INDX_set = *libstdfc::rec_pgr_GRP_INDX_set;
*swig_GRP_NAM_get = *libstdfc::rec_pgr_GRP_NAM_get;
*swig_GRP_NAM_set = *libstdfc::rec_pgr_GRP_NAM_set;
*swig_INDX_CNT_get = *libstdfc::rec_pgr_INDX_CNT_get;
*swig_INDX_CNT_set = *libstdfc::rec_pgr_INDX_CNT_set;
*swig_PMR_INDX_get = *libstdfc::rec_pgr_PMR_INDX_get;
*swig_PMR_INDX_set = *libstdfc::rec_pgr_PMR_INDX_set;
sub new {
    my $pkg = shift;
    my $self = libstdfc::new_rec_pgr(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libstdfc::delete_rec_pgr($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libstdf::rec_plr ##############

package libstdf::rec_plr;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libstdf );
%OWNER = ();
%ITERATORS = ();
*swig_header_get = *libstdfc::rec_plr_header_get;
*swig_header_set = *libstdfc::rec_plr_header_set;
*swig_GRP_CNT_get = *libstdfc::rec_plr_GRP_CNT_get;
*swig_GRP_CNT_set = *libstdfc::rec_plr_GRP_CNT_set;
*swig_GRP_INDX_get = *libstdfc::rec_plr_GRP_INDX_get;
*swig_GRP_INDX_set = *libstdfc::rec_plr_GRP_INDX_set;
*swig_GRP_MODE_get = *libstdfc::rec_plr_GRP_MODE_get;
*swig_GRP_MODE_set = *libstdfc::rec_plr_GRP_MODE_set;
*swig_GRP_RADX_get = *libstdfc::rec_plr_GRP_RADX_get;
*swig_GRP_RADX_set = *libstdfc::rec_plr_GRP_RADX_set;
*swig_PGM_CHAR_get = *libstdfc::rec_plr_PGM_CHAR_get;
*swig_PGM_CHAR_set = *libstdfc::rec_plr_PGM_CHAR_set;
*swig_RTN_CHAR_get = *libstdfc::rec_plr_RTN_CHAR_get;
*swig_RTN_CHAR_set = *libstdfc::rec_plr_RTN_CHAR_set;
*swig_PGM_CHAL_get = *libstdfc::rec_plr_PGM_CHAL_get;
*swig_PGM_CHAL_set = *libstdfc::rec_plr_PGM_CHAL_set;
*swig_RTN_CHAL_get = *libstdfc::rec_plr_RTN_CHAL_get;
*swig_RTN_CHAL_set = *libstdfc::rec_plr_RTN_CHAL_set;
sub new {
    my $pkg = shift;
    my $self = libstdfc::new_rec_plr(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libstdfc::delete_rec_plr($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libstdf::rec_rdr ##############

package libstdf::rec_rdr;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libstdf );
%OWNER = ();
%ITERATORS = ();
*swig_header_get = *libstdfc::rec_rdr_header_get;
*swig_header_set = *libstdfc::rec_rdr_header_set;
*swig_NUM_BINS_get = *libstdfc::rec_rdr_NUM_BINS_get;
*swig_NUM_BINS_set = *libstdfc::rec_rdr_NUM_BINS_set;
*swig_RTST_BIN_get = *libstdfc::rec_rdr_RTST_BIN_get;
*swig_RTST_BIN_set = *libstdfc::rec_rdr_RTST_BIN_set;
sub new {
    my $pkg = shift;
    my $self = libstdfc::new_rec_rdr(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libstdfc::delete_rec_rdr($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libstdf::rec_sdr ##############

package libstdf::rec_sdr;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libstdf );
%OWNER = ();
%ITERATORS = ();
*swig_header_get = *libstdfc::rec_sdr_header_get;
*swig_header_set = *libstdfc::rec_sdr_header_set;
*swig_HEAD_NUM_get = *libstdfc::rec_sdr_HEAD_NUM_get;
*swig_HEAD_NUM_set = *libstdfc::rec_sdr_HEAD_NUM_set;
*swig_SITE_GRP_get = *libstdfc::rec_sdr_SITE_GRP_get;
*swig_SITE_GRP_set = *libstdfc::rec_sdr_SITE_GRP_set;
*swig_SITE_CNT_get = *libstdfc::rec_sdr_SITE_CNT_get;
*swig_SITE_CNT_set = *libstdfc::rec_sdr_SITE_CNT_set;
*swig_SITE_NUM_get = *libstdfc::rec_sdr_SITE_NUM_get;
*swig_SITE_NUM_set = *libstdfc::rec_sdr_SITE_NUM_set;
*swig_HAND_TYP_get = *libstdfc::rec_sdr_HAND_TYP_get;
*swig_HAND_TYP_set = *libstdfc::rec_sdr_HAND_TYP_set;
*swig_HAND_ID_get = *libstdfc::rec_sdr_HAND_ID_get;
*swig_HAND_ID_set = *libstdfc::rec_sdr_HAND_ID_set;
*swig_CARD_TYP_get = *libstdfc::rec_sdr_CARD_TYP_get;
*swig_CARD_TYP_set = *libstdfc::rec_sdr_CARD_TYP_set;
*swig_CARD_ID_get = *libstdfc::rec_sdr_CARD_ID_get;
*swig_CARD_ID_set = *libstdfc::rec_sdr_CARD_ID_set;
*swig_LOAD_TYP_get = *libstdfc::rec_sdr_LOAD_TYP_get;
*swig_LOAD_TYP_set = *libstdfc::rec_sdr_LOAD_TYP_set;
*swig_LOAD_ID_get = *libstdfc::rec_sdr_LOAD_ID_get;
*swig_LOAD_ID_set = *libstdfc::rec_sdr_LOAD_ID_set;
*swig_DIB_TYP_get = *libstdfc::rec_sdr_DIB_TYP_get;
*swig_DIB_TYP_set = *libstdfc::rec_sdr_DIB_TYP_set;
*swig_DIB_ID_get = *libstdfc::rec_sdr_DIB_ID_get;
*swig_DIB_ID_set = *libstdfc::rec_sdr_DIB_ID_set;
*swig_CABL_TYP_get = *libstdfc::rec_sdr_CABL_TYP_get;
*swig_CABL_TYP_set = *libstdfc::rec_sdr_CABL_TYP_set;
*swig_CABL_ID_get = *libstdfc::rec_sdr_CABL_ID_get;
*swig_CABL_ID_set = *libstdfc::rec_sdr_CABL_ID_set;
*swig_CONT_TYP_get = *libstdfc::rec_sdr_CONT_TYP_get;
*swig_CONT_TYP_set = *libstdfc::rec_sdr_CONT_TYP_set;
*swig_CONT_ID_get = *libstdfc::rec_sdr_CONT_ID_get;
*swig_CONT_ID_set = *libstdfc::rec_sdr_CONT_ID_set;
*swig_LASR_TYP_get = *libstdfc::rec_sdr_LASR_TYP_get;
*swig_LASR_TYP_set = *libstdfc::rec_sdr_LASR_TYP_set;
*swig_LASR_ID_get = *libstdfc::rec_sdr_LASR_ID_get;
*swig_LASR_ID_set = *libstdfc::rec_sdr_LASR_ID_set;
*swig_EXTR_TYP_get = *libstdfc::rec_sdr_EXTR_TYP_get;
*swig_EXTR_TYP_set = *libstdfc::rec_sdr_EXTR_TYP_set;
*swig_EXTR_ID_get = *libstdfc::rec_sdr_EXTR_ID_get;
*swig_EXTR_ID_set = *libstdfc::rec_sdr_EXTR_ID_set;
sub new {
    my $pkg = shift;
    my $self = libstdfc::new_rec_sdr(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libstdfc::delete_rec_sdr($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libstdf::rec_wir ##############

package libstdf::rec_wir;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libstdf );
%OWNER = ();
%ITERATORS = ();
*swig_header_get = *libstdfc::rec_wir_header_get;
*swig_header_set = *libstdfc::rec_wir_header_set;
*swig_HEAD_NUM_get = *libstdfc::rec_wir_HEAD_NUM_get;
*swig_HEAD_NUM_set = *libstdfc::rec_wir_HEAD_NUM_set;
*swig_SITE_GRP_get = *libstdfc::rec_wir_SITE_GRP_get;
*swig_SITE_GRP_set = *libstdfc::rec_wir_SITE_GRP_set;
*swig_START_T_get = *libstdfc::rec_wir_START_T_get;
*swig_START_T_set = *libstdfc::rec_wir_START_T_set;
*swig_WAFER_ID_get = *libstdfc::rec_wir_WAFER_ID_get;
*swig_WAFER_ID_set = *libstdfc::rec_wir_WAFER_ID_set;
sub new {
    my $pkg = shift;
    my $self = libstdfc::new_rec_wir(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libstdfc::delete_rec_wir($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libstdf::rec_wrr ##############

package libstdf::rec_wrr;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libstdf );
%OWNER = ();
%ITERATORS = ();
*swig_header_get = *libstdfc::rec_wrr_header_get;
*swig_header_set = *libstdfc::rec_wrr_header_set;
*swig_HEAD_NUM_get = *libstdfc::rec_wrr_HEAD_NUM_get;
*swig_HEAD_NUM_set = *libstdfc::rec_wrr_HEAD_NUM_set;
*swig_SITE_GRP_get = *libstdfc::rec_wrr_SITE_GRP_get;
*swig_SITE_GRP_set = *libstdfc::rec_wrr_SITE_GRP_set;
*swig_FINISH_T_get = *libstdfc::rec_wrr_FINISH_T_get;
*swig_FINISH_T_set = *libstdfc::rec_wrr_FINISH_T_set;
*swig_PART_CNT_get = *libstdfc::rec_wrr_PART_CNT_get;
*swig_PART_CNT_set = *libstdfc::rec_wrr_PART_CNT_set;
*swig_RTST_CNT_get = *libstdfc::rec_wrr_RTST_CNT_get;
*swig_RTST_CNT_set = *libstdfc::rec_wrr_RTST_CNT_set;
*swig_ABRT_CNT_get = *libstdfc::rec_wrr_ABRT_CNT_get;
*swig_ABRT_CNT_set = *libstdfc::rec_wrr_ABRT_CNT_set;
*swig_GOOD_CNT_get = *libstdfc::rec_wrr_GOOD_CNT_get;
*swig_GOOD_CNT_set = *libstdfc::rec_wrr_GOOD_CNT_set;
*swig_FUNC_CNT_get = *libstdfc::rec_wrr_FUNC_CNT_get;
*swig_FUNC_CNT_set = *libstdfc::rec_wrr_FUNC_CNT_set;
*swig_WAFER_ID_get = *libstdfc::rec_wrr_WAFER_ID_get;
*swig_WAFER_ID_set = *libstdfc::rec_wrr_WAFER_ID_set;
*swig_FABWF_ID_get = *libstdfc::rec_wrr_FABWF_ID_get;
*swig_FABWF_ID_set = *libstdfc::rec_wrr_FABWF_ID_set;
*swig_FRAME_ID_get = *libstdfc::rec_wrr_FRAME_ID_get;
*swig_FRAME_ID_set = *libstdfc::rec_wrr_FRAME_ID_set;
*swig_MASK_ID_get = *libstdfc::rec_wrr_MASK_ID_get;
*swig_MASK_ID_set = *libstdfc::rec_wrr_MASK_ID_set;
*swig_USR_DESC_get = *libstdfc::rec_wrr_USR_DESC_get;
*swig_USR_DESC_set = *libstdfc::rec_wrr_USR_DESC_set;
*swig_EXC_DESC_get = *libstdfc::rec_wrr_EXC_DESC_get;
*swig_EXC_DESC_set = *libstdfc::rec_wrr_EXC_DESC_set;
sub new {
    my $pkg = shift;
    my $self = libstdfc::new_rec_wrr(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libstdfc::delete_rec_wrr($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libstdf::rec_wcr ##############

package libstdf::rec_wcr;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libstdf );
%OWNER = ();
%ITERATORS = ();
*swig_header_get = *libstdfc::rec_wcr_header_get;
*swig_header_set = *libstdfc::rec_wcr_header_set;
*swig_WAFR_SIZ_get = *libstdfc::rec_wcr_WAFR_SIZ_get;
*swig_WAFR_SIZ_set = *libstdfc::rec_wcr_WAFR_SIZ_set;
*swig_DIE_HT_get = *libstdfc::rec_wcr_DIE_HT_get;
*swig_DIE_HT_set = *libstdfc::rec_wcr_DIE_HT_set;
*swig_DIE_WID_get = *libstdfc::rec_wcr_DIE_WID_get;
*swig_DIE_WID_set = *libstdfc::rec_wcr_DIE_WID_set;
*swig_WF_UNITS_get = *libstdfc::rec_wcr_WF_UNITS_get;
*swig_WF_UNITS_set = *libstdfc::rec_wcr_WF_UNITS_set;
*swig_WF_FLAT_get = *libstdfc::rec_wcr_WF_FLAT_get;
*swig_WF_FLAT_set = *libstdfc::rec_wcr_WF_FLAT_set;
*swig_CENTER_X_get = *libstdfc::rec_wcr_CENTER_X_get;
*swig_CENTER_X_set = *libstdfc::rec_wcr_CENTER_X_set;
*swig_CENTER_Y_get = *libstdfc::rec_wcr_CENTER_Y_get;
*swig_CENTER_Y_set = *libstdfc::rec_wcr_CENTER_Y_set;
*swig_POS_X_get = *libstdfc::rec_wcr_POS_X_get;
*swig_POS_X_set = *libstdfc::rec_wcr_POS_X_set;
*swig_POS_Y_get = *libstdfc::rec_wcr_POS_Y_get;
*swig_POS_Y_set = *libstdfc::rec_wcr_POS_Y_set;
sub new {
    my $pkg = shift;
    my $self = libstdfc::new_rec_wcr(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libstdfc::delete_rec_wcr($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libstdf::rec_pir ##############

package libstdf::rec_pir;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libstdf );
%OWNER = ();
%ITERATORS = ();
*swig_header_get = *libstdfc::rec_pir_header_get;
*swig_header_set = *libstdfc::rec_pir_header_set;
*swig_HEAD_NUM_get = *libstdfc::rec_pir_HEAD_NUM_get;
*swig_HEAD_NUM_set = *libstdfc::rec_pir_HEAD_NUM_set;
*swig_SITE_NUM_get = *libstdfc::rec_pir_SITE_NUM_get;
*swig_SITE_NUM_set = *libstdfc::rec_pir_SITE_NUM_set;
sub new {
    my $pkg = shift;
    my $self = libstdfc::new_rec_pir(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libstdfc::delete_rec_pir($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libstdf::rec_prr ##############

package libstdf::rec_prr;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libstdf );
%OWNER = ();
%ITERATORS = ();
*swig_header_get = *libstdfc::rec_prr_header_get;
*swig_header_set = *libstdfc::rec_prr_header_set;
*swig_HEAD_NUM_get = *libstdfc::rec_prr_HEAD_NUM_get;
*swig_HEAD_NUM_set = *libstdfc::rec_prr_HEAD_NUM_set;
*swig_SITE_NUM_get = *libstdfc::rec_prr_SITE_NUM_get;
*swig_SITE_NUM_set = *libstdfc::rec_prr_SITE_NUM_set;
*swig_PART_FLG_get = *libstdfc::rec_prr_PART_FLG_get;
*swig_PART_FLG_set = *libstdfc::rec_prr_PART_FLG_set;
*swig_NUM_TEST_get = *libstdfc::rec_prr_NUM_TEST_get;
*swig_NUM_TEST_set = *libstdfc::rec_prr_NUM_TEST_set;
*swig_HARD_BIN_get = *libstdfc::rec_prr_HARD_BIN_get;
*swig_HARD_BIN_set = *libstdfc::rec_prr_HARD_BIN_set;
*swig_SOFT_BIN_get = *libstdfc::rec_prr_SOFT_BIN_get;
*swig_SOFT_BIN_set = *libstdfc::rec_prr_SOFT_BIN_set;
*swig_X_COORD_get = *libstdfc::rec_prr_X_COORD_get;
*swig_X_COORD_set = *libstdfc::rec_prr_X_COORD_set;
*swig_Y_COORD_get = *libstdfc::rec_prr_Y_COORD_get;
*swig_Y_COORD_set = *libstdfc::rec_prr_Y_COORD_set;
*swig_TEST_T_get = *libstdfc::rec_prr_TEST_T_get;
*swig_TEST_T_set = *libstdfc::rec_prr_TEST_T_set;
*swig_PART_ID_get = *libstdfc::rec_prr_PART_ID_get;
*swig_PART_ID_set = *libstdfc::rec_prr_PART_ID_set;
*swig_PART_TXT_get = *libstdfc::rec_prr_PART_TXT_get;
*swig_PART_TXT_set = *libstdfc::rec_prr_PART_TXT_set;
*swig_PART_FIX_get = *libstdfc::rec_prr_PART_FIX_get;
*swig_PART_FIX_set = *libstdfc::rec_prr_PART_FIX_set;
sub new {
    my $pkg = shift;
    my $self = libstdfc::new_rec_prr(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libstdfc::delete_rec_prr($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libstdf::rec_tsr ##############

package libstdf::rec_tsr;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libstdf );
%OWNER = ();
%ITERATORS = ();
*swig_header_get = *libstdfc::rec_tsr_header_get;
*swig_header_set = *libstdfc::rec_tsr_header_set;
*swig_HEAD_NUM_get = *libstdfc::rec_tsr_HEAD_NUM_get;
*swig_HEAD_NUM_set = *libstdfc::rec_tsr_HEAD_NUM_set;
*swig_SITE_NUM_get = *libstdfc::rec_tsr_SITE_NUM_get;
*swig_SITE_NUM_set = *libstdfc::rec_tsr_SITE_NUM_set;
*swig_TEST_TYP_get = *libstdfc::rec_tsr_TEST_TYP_get;
*swig_TEST_TYP_set = *libstdfc::rec_tsr_TEST_TYP_set;
*swig_TEST_NUM_get = *libstdfc::rec_tsr_TEST_NUM_get;
*swig_TEST_NUM_set = *libstdfc::rec_tsr_TEST_NUM_set;
*swig_EXEC_CNT_get = *libstdfc::rec_tsr_EXEC_CNT_get;
*swig_EXEC_CNT_set = *libstdfc::rec_tsr_EXEC_CNT_set;
*swig_FAIL_CNT_get = *libstdfc::rec_tsr_FAIL_CNT_get;
*swig_FAIL_CNT_set = *libstdfc::rec_tsr_FAIL_CNT_set;
*swig_ALRM_CNT_get = *libstdfc::rec_tsr_ALRM_CNT_get;
*swig_ALRM_CNT_set = *libstdfc::rec_tsr_ALRM_CNT_set;
*swig_TEST_NAM_get = *libstdfc::rec_tsr_TEST_NAM_get;
*swig_TEST_NAM_set = *libstdfc::rec_tsr_TEST_NAM_set;
*swig_SEQ_NAME_get = *libstdfc::rec_tsr_SEQ_NAME_get;
*swig_SEQ_NAME_set = *libstdfc::rec_tsr_SEQ_NAME_set;
*swig_TEST_LBL_get = *libstdfc::rec_tsr_TEST_LBL_get;
*swig_TEST_LBL_set = *libstdfc::rec_tsr_TEST_LBL_set;
*swig_OPT_FLAG_get = *libstdfc::rec_tsr_OPT_FLAG_get;
*swig_OPT_FLAG_set = *libstdfc::rec_tsr_OPT_FLAG_set;
*swig_TEST_TIM_get = *libstdfc::rec_tsr_TEST_TIM_get;
*swig_TEST_TIM_set = *libstdfc::rec_tsr_TEST_TIM_set;
*swig_TEST_MIN_get = *libstdfc::rec_tsr_TEST_MIN_get;
*swig_TEST_MIN_set = *libstdfc::rec_tsr_TEST_MIN_set;
*swig_TEST_MAX_get = *libstdfc::rec_tsr_TEST_MAX_get;
*swig_TEST_MAX_set = *libstdfc::rec_tsr_TEST_MAX_set;
*swig_TST_SUMS_get = *libstdfc::rec_tsr_TST_SUMS_get;
*swig_TST_SUMS_set = *libstdfc::rec_tsr_TST_SUMS_set;
*swig_TST_SQRS_get = *libstdfc::rec_tsr_TST_SQRS_get;
*swig_TST_SQRS_set = *libstdfc::rec_tsr_TST_SQRS_set;
sub new {
    my $pkg = shift;
    my $self = libstdfc::new_rec_tsr(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libstdfc::delete_rec_tsr($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libstdf::rec_ptr ##############

package libstdf::rec_ptr;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libstdf );
%OWNER = ();
%ITERATORS = ();
*swig_header_get = *libstdfc::rec_ptr_header_get;
*swig_header_set = *libstdfc::rec_ptr_header_set;
*swig_TEST_NUM_get = *libstdfc::rec_ptr_TEST_NUM_get;
*swig_TEST_NUM_set = *libstdfc::rec_ptr_TEST_NUM_set;
*swig_HEAD_NUM_get = *libstdfc::rec_ptr_HEAD_NUM_get;
*swig_HEAD_NUM_set = *libstdfc::rec_ptr_HEAD_NUM_set;
*swig_SITE_NUM_get = *libstdfc::rec_ptr_SITE_NUM_get;
*swig_SITE_NUM_set = *libstdfc::rec_ptr_SITE_NUM_set;
*swig_TEST_FLG_get = *libstdfc::rec_ptr_TEST_FLG_get;
*swig_TEST_FLG_set = *libstdfc::rec_ptr_TEST_FLG_set;
*swig_PARM_FLG_get = *libstdfc::rec_ptr_PARM_FLG_get;
*swig_PARM_FLG_set = *libstdfc::rec_ptr_PARM_FLG_set;
*swig_RESULT_get = *libstdfc::rec_ptr_RESULT_get;
*swig_RESULT_set = *libstdfc::rec_ptr_RESULT_set;
*swig_TEST_TXT_get = *libstdfc::rec_ptr_TEST_TXT_get;
*swig_TEST_TXT_set = *libstdfc::rec_ptr_TEST_TXT_set;
*swig_ALARM_ID_get = *libstdfc::rec_ptr_ALARM_ID_get;
*swig_ALARM_ID_set = *libstdfc::rec_ptr_ALARM_ID_set;
*swig_OPT_FLAG_get = *libstdfc::rec_ptr_OPT_FLAG_get;
*swig_OPT_FLAG_set = *libstdfc::rec_ptr_OPT_FLAG_set;
*swig_RES_SCAL_get = *libstdfc::rec_ptr_RES_SCAL_get;
*swig_RES_SCAL_set = *libstdfc::rec_ptr_RES_SCAL_set;
*swig_LLM_SCAL_get = *libstdfc::rec_ptr_LLM_SCAL_get;
*swig_LLM_SCAL_set = *libstdfc::rec_ptr_LLM_SCAL_set;
*swig_HLM_SCAL_get = *libstdfc::rec_ptr_HLM_SCAL_get;
*swig_HLM_SCAL_set = *libstdfc::rec_ptr_HLM_SCAL_set;
*swig_LO_LIMIT_get = *libstdfc::rec_ptr_LO_LIMIT_get;
*swig_LO_LIMIT_set = *libstdfc::rec_ptr_LO_LIMIT_set;
*swig_HI_LIMIT_get = *libstdfc::rec_ptr_HI_LIMIT_get;
*swig_HI_LIMIT_set = *libstdfc::rec_ptr_HI_LIMIT_set;
*swig_UNITS_get = *libstdfc::rec_ptr_UNITS_get;
*swig_UNITS_set = *libstdfc::rec_ptr_UNITS_set;
*swig_C_RESFMT_get = *libstdfc::rec_ptr_C_RESFMT_get;
*swig_C_RESFMT_set = *libstdfc::rec_ptr_C_RESFMT_set;
*swig_C_LLMFMT_get = *libstdfc::rec_ptr_C_LLMFMT_get;
*swig_C_LLMFMT_set = *libstdfc::rec_ptr_C_LLMFMT_set;
*swig_C_HLMFMT_get = *libstdfc::rec_ptr_C_HLMFMT_get;
*swig_C_HLMFMT_set = *libstdfc::rec_ptr_C_HLMFMT_set;
*swig_LO_SPEC_get = *libstdfc::rec_ptr_LO_SPEC_get;
*swig_LO_SPEC_set = *libstdfc::rec_ptr_LO_SPEC_set;
*swig_HI_SPEC_get = *libstdfc::rec_ptr_HI_SPEC_get;
*swig_HI_SPEC_set = *libstdfc::rec_ptr_HI_SPEC_set;
sub new {
    my $pkg = shift;
    my $self = libstdfc::new_rec_ptr(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libstdfc::delete_rec_ptr($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libstdf::rec_mpr ##############

package libstdf::rec_mpr;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libstdf );
%OWNER = ();
%ITERATORS = ();
*swig_header_get = *libstdfc::rec_mpr_header_get;
*swig_header_set = *libstdfc::rec_mpr_header_set;
*swig_TEST_NUM_get = *libstdfc::rec_mpr_TEST_NUM_get;
*swig_TEST_NUM_set = *libstdfc::rec_mpr_TEST_NUM_set;
*swig_HEAD_NUM_get = *libstdfc::rec_mpr_HEAD_NUM_get;
*swig_HEAD_NUM_set = *libstdfc::rec_mpr_HEAD_NUM_set;
*swig_SITE_NUM_get = *libstdfc::rec_mpr_SITE_NUM_get;
*swig_SITE_NUM_set = *libstdfc::rec_mpr_SITE_NUM_set;
*swig_TEST_FLG_get = *libstdfc::rec_mpr_TEST_FLG_get;
*swig_TEST_FLG_set = *libstdfc::rec_mpr_TEST_FLG_set;
*swig_PARM_FLG_get = *libstdfc::rec_mpr_PARM_FLG_get;
*swig_PARM_FLG_set = *libstdfc::rec_mpr_PARM_FLG_set;
*swig_RTN_ICNT_get = *libstdfc::rec_mpr_RTN_ICNT_get;
*swig_RTN_ICNT_set = *libstdfc::rec_mpr_RTN_ICNT_set;
*swig_RSLT_CNT_get = *libstdfc::rec_mpr_RSLT_CNT_get;
*swig_RSLT_CNT_set = *libstdfc::rec_mpr_RSLT_CNT_set;
*swig_RTN_STAT_get = *libstdfc::rec_mpr_RTN_STAT_get;
*swig_RTN_STAT_set = *libstdfc::rec_mpr_RTN_STAT_set;
*swig_RTN_RSLT_get = *libstdfc::rec_mpr_RTN_RSLT_get;
*swig_RTN_RSLT_set = *libstdfc::rec_mpr_RTN_RSLT_set;
*swig_TEST_TXT_get = *libstdfc::rec_mpr_TEST_TXT_get;
*swig_TEST_TXT_set = *libstdfc::rec_mpr_TEST_TXT_set;
*swig_ALARM_ID_get = *libstdfc::rec_mpr_ALARM_ID_get;
*swig_ALARM_ID_set = *libstdfc::rec_mpr_ALARM_ID_set;
*swig_OPT_FLAG_get = *libstdfc::rec_mpr_OPT_FLAG_get;
*swig_OPT_FLAG_set = *libstdfc::rec_mpr_OPT_FLAG_set;
*swig_RES_SCAL_get = *libstdfc::rec_mpr_RES_SCAL_get;
*swig_RES_SCAL_set = *libstdfc::rec_mpr_RES_SCAL_set;
*swig_LLM_SCAL_get = *libstdfc::rec_mpr_LLM_SCAL_get;
*swig_LLM_SCAL_set = *libstdfc::rec_mpr_LLM_SCAL_set;
*swig_HLM_SCAL_get = *libstdfc::rec_mpr_HLM_SCAL_get;
*swig_HLM_SCAL_set = *libstdfc::rec_mpr_HLM_SCAL_set;
*swig_LO_LIMIT_get = *libstdfc::rec_mpr_LO_LIMIT_get;
*swig_LO_LIMIT_set = *libstdfc::rec_mpr_LO_LIMIT_set;
*swig_HI_LIMIT_get = *libstdfc::rec_mpr_HI_LIMIT_get;
*swig_HI_LIMIT_set = *libstdfc::rec_mpr_HI_LIMIT_set;
*swig_START_IN_get = *libstdfc::rec_mpr_START_IN_get;
*swig_START_IN_set = *libstdfc::rec_mpr_START_IN_set;
*swig_INCR_IN_get = *libstdfc::rec_mpr_INCR_IN_get;
*swig_INCR_IN_set = *libstdfc::rec_mpr_INCR_IN_set;
*swig_RTN_INDX_get = *libstdfc::rec_mpr_RTN_INDX_get;
*swig_RTN_INDX_set = *libstdfc::rec_mpr_RTN_INDX_set;
*swig_UNITS_get = *libstdfc::rec_mpr_UNITS_get;
*swig_UNITS_set = *libstdfc::rec_mpr_UNITS_set;
*swig_UNITS_IN_get = *libstdfc::rec_mpr_UNITS_IN_get;
*swig_UNITS_IN_set = *libstdfc::rec_mpr_UNITS_IN_set;
*swig_C_RESFMT_get = *libstdfc::rec_mpr_C_RESFMT_get;
*swig_C_RESFMT_set = *libstdfc::rec_mpr_C_RESFMT_set;
*swig_C_LLMFMT_get = *libstdfc::rec_mpr_C_LLMFMT_get;
*swig_C_LLMFMT_set = *libstdfc::rec_mpr_C_LLMFMT_set;
*swig_C_HLMFMT_get = *libstdfc::rec_mpr_C_HLMFMT_get;
*swig_C_HLMFMT_set = *libstdfc::rec_mpr_C_HLMFMT_set;
*swig_LO_SPEC_get = *libstdfc::rec_mpr_LO_SPEC_get;
*swig_LO_SPEC_set = *libstdfc::rec_mpr_LO_SPEC_set;
*swig_HI_SPEC_get = *libstdfc::rec_mpr_HI_SPEC_get;
*swig_HI_SPEC_set = *libstdfc::rec_mpr_HI_SPEC_set;
sub new {
    my $pkg = shift;
    my $self = libstdfc::new_rec_mpr(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libstdfc::delete_rec_mpr($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libstdf::rec_ftr ##############

package libstdf::rec_ftr;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libstdf );
%OWNER = ();
%ITERATORS = ();
*swig_header_get = *libstdfc::rec_ftr_header_get;
*swig_header_set = *libstdfc::rec_ftr_header_set;
*swig_TEST_NUM_get = *libstdfc::rec_ftr_TEST_NUM_get;
*swig_TEST_NUM_set = *libstdfc::rec_ftr_TEST_NUM_set;
*swig_HEAD_NUM_get = *libstdfc::rec_ftr_HEAD_NUM_get;
*swig_HEAD_NUM_set = *libstdfc::rec_ftr_HEAD_NUM_set;
*swig_SITE_NUM_get = *libstdfc::rec_ftr_SITE_NUM_get;
*swig_SITE_NUM_set = *libstdfc::rec_ftr_SITE_NUM_set;
*swig_TEST_FLG_get = *libstdfc::rec_ftr_TEST_FLG_get;
*swig_TEST_FLG_set = *libstdfc::rec_ftr_TEST_FLG_set;
*swig_OPT_FLAG_get = *libstdfc::rec_ftr_OPT_FLAG_get;
*swig_OPT_FLAG_set = *libstdfc::rec_ftr_OPT_FLAG_set;
*swig_CYCL_CNT_get = *libstdfc::rec_ftr_CYCL_CNT_get;
*swig_CYCL_CNT_set = *libstdfc::rec_ftr_CYCL_CNT_set;
*swig_REL_VADR_get = *libstdfc::rec_ftr_REL_VADR_get;
*swig_REL_VADR_set = *libstdfc::rec_ftr_REL_VADR_set;
*swig_REPT_CNT_get = *libstdfc::rec_ftr_REPT_CNT_get;
*swig_REPT_CNT_set = *libstdfc::rec_ftr_REPT_CNT_set;
*swig_NUM_FAIL_get = *libstdfc::rec_ftr_NUM_FAIL_get;
*swig_NUM_FAIL_set = *libstdfc::rec_ftr_NUM_FAIL_set;
*swig_XFAIL_AD_get = *libstdfc::rec_ftr_XFAIL_AD_get;
*swig_XFAIL_AD_set = *libstdfc::rec_ftr_XFAIL_AD_set;
*swig_YFAIL_AD_get = *libstdfc::rec_ftr_YFAIL_AD_get;
*swig_YFAIL_AD_set = *libstdfc::rec_ftr_YFAIL_AD_set;
*swig_VECT_OFF_get = *libstdfc::rec_ftr_VECT_OFF_get;
*swig_VECT_OFF_set = *libstdfc::rec_ftr_VECT_OFF_set;
*swig_RTN_ICNT_get = *libstdfc::rec_ftr_RTN_ICNT_get;
*swig_RTN_ICNT_set = *libstdfc::rec_ftr_RTN_ICNT_set;
*swig_PGM_ICNT_get = *libstdfc::rec_ftr_PGM_ICNT_get;
*swig_PGM_ICNT_set = *libstdfc::rec_ftr_PGM_ICNT_set;
*swig_RTN_INDX_get = *libstdfc::rec_ftr_RTN_INDX_get;
*swig_RTN_INDX_set = *libstdfc::rec_ftr_RTN_INDX_set;
*swig_RTN_STAT_get = *libstdfc::rec_ftr_RTN_STAT_get;
*swig_RTN_STAT_set = *libstdfc::rec_ftr_RTN_STAT_set;
*swig_PGM_INDX_get = *libstdfc::rec_ftr_PGM_INDX_get;
*swig_PGM_INDX_set = *libstdfc::rec_ftr_PGM_INDX_set;
*swig_PGM_STAT_get = *libstdfc::rec_ftr_PGM_STAT_get;
*swig_PGM_STAT_set = *libstdfc::rec_ftr_PGM_STAT_set;
*swig_FAIL_PIN_get = *libstdfc::rec_ftr_FAIL_PIN_get;
*swig_FAIL_PIN_set = *libstdfc::rec_ftr_FAIL_PIN_set;
*swig_VECT_NAM_get = *libstdfc::rec_ftr_VECT_NAM_get;
*swig_VECT_NAM_set = *libstdfc::rec_ftr_VECT_NAM_set;
*swig_TIME_SET_get = *libstdfc::rec_ftr_TIME_SET_get;
*swig_TIME_SET_set = *libstdfc::rec_ftr_TIME_SET_set;
*swig_OP_CODE_get = *libstdfc::rec_ftr_OP_CODE_get;
*swig_OP_CODE_set = *libstdfc::rec_ftr_OP_CODE_set;
*swig_TEST_TXT_get = *libstdfc::rec_ftr_TEST_TXT_get;
*swig_TEST_TXT_set = *libstdfc::rec_ftr_TEST_TXT_set;
*swig_ALARM_ID_get = *libstdfc::rec_ftr_ALARM_ID_get;
*swig_ALARM_ID_set = *libstdfc::rec_ftr_ALARM_ID_set;
*swig_PROG_TXT_get = *libstdfc::rec_ftr_PROG_TXT_get;
*swig_PROG_TXT_set = *libstdfc::rec_ftr_PROG_TXT_set;
*swig_RSLT_TXT_get = *libstdfc::rec_ftr_RSLT_TXT_get;
*swig_RSLT_TXT_set = *libstdfc::rec_ftr_RSLT_TXT_set;
*swig_PATG_NUM_get = *libstdfc::rec_ftr_PATG_NUM_get;
*swig_PATG_NUM_set = *libstdfc::rec_ftr_PATG_NUM_set;
*swig_SPIN_MAP_get = *libstdfc::rec_ftr_SPIN_MAP_get;
*swig_SPIN_MAP_set = *libstdfc::rec_ftr_SPIN_MAP_set;
sub new {
    my $pkg = shift;
    my $self = libstdfc::new_rec_ftr(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libstdfc::delete_rec_ftr($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libstdf::rec_bps ##############

package libstdf::rec_bps;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libstdf );
%OWNER = ();
%ITERATORS = ();
*swig_header_get = *libstdfc::rec_bps_header_get;
*swig_header_set = *libstdfc::rec_bps_header_set;
*swig_SEQ_NAME_get = *libstdfc::rec_bps_SEQ_NAME_get;
*swig_SEQ_NAME_set = *libstdfc::rec_bps_SEQ_NAME_set;
sub new {
    my $pkg = shift;
    my $self = libstdfc::new_rec_bps(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libstdfc::delete_rec_bps($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libstdf::rec_eps ##############

package libstdf::rec_eps;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libstdf );
%OWNER = ();
%ITERATORS = ();
*swig_header_get = *libstdfc::rec_eps_header_get;
*swig_header_set = *libstdfc::rec_eps_header_set;
sub new {
    my $pkg = shift;
    my $self = libstdfc::new_rec_eps(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libstdfc::delete_rec_eps($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libstdf::rec_gdr ##############

package libstdf::rec_gdr;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libstdf );
%OWNER = ();
%ITERATORS = ();
*swig_header_get = *libstdfc::rec_gdr_header_get;
*swig_header_set = *libstdfc::rec_gdr_header_set;
*swig_FLD_CNT_get = *libstdfc::rec_gdr_FLD_CNT_get;
*swig_FLD_CNT_set = *libstdfc::rec_gdr_FLD_CNT_set;
*swig_GEN_DATA_get = *libstdfc::rec_gdr_GEN_DATA_get;
*swig_GEN_DATA_set = *libstdfc::rec_gdr_GEN_DATA_set;
sub new {
    my $pkg = shift;
    my $self = libstdfc::new_rec_gdr(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libstdfc::delete_rec_gdr($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : libstdf::rec_dtr ##############

package libstdf::rec_dtr;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( libstdf );
%OWNER = ();
%ITERATORS = ();
*swig_header_get = *libstdfc::rec_dtr_header_get;
*swig_header_set = *libstdfc::rec_dtr_header_set;
*swig_TEXT_DAT_get = *libstdfc::rec_dtr_TEXT_DAT_get;
*swig_TEXT_DAT_set = *libstdfc::rec_dtr_TEXT_DAT_set;
sub new {
    my $pkg = shift;
    my $self = libstdfc::new_rec_dtr(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        libstdfc::delete_rec_dtr($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package libstdf;

*STDF_FORMAT_REG = *libstdfc::STDF_FORMAT_REG;
*STDF_FORMAT_ZIP = *libstdfc::STDF_FORMAT_ZIP;
*STDF_FORMAT_GZIP = *libstdfc::STDF_FORMAT_GZIP;
*STDF_FORMAT_BZIP2 = *libstdfc::STDF_FORMAT_BZIP2;
*STDF_FORMAT_LZW = *libstdfc::STDF_FORMAT_LZW;
*STDF_OPTS_DEFAULT = *libstdfc::STDF_OPTS_DEFAULT;
*STDF_OPTS_FORCE = *libstdfc::STDF_OPTS_FORCE;
*STDF_OPTS_FORCE_V3 = *libstdfc::STDF_OPTS_FORCE_V3;
*STDF_OPTS_FORCE_V4 = *libstdfc::STDF_OPTS_FORCE_V4;
*STDF_OPTS_ZIP = *libstdfc::STDF_OPTS_ZIP;
*STDF_OPTS_GZIP = *libstdfc::STDF_OPTS_GZIP;
*STDF_OPTS_BZIP2 = *libstdfc::STDF_OPTS_BZIP2;
*STDF_OPTS_LZW = *libstdfc::STDF_OPTS_LZW;
*STDF_OPTS_READ = *libstdfc::STDF_OPTS_READ;
*STDF_OPTS_WRITE = *libstdfc::STDF_OPTS_WRITE;
*STDF_OPTS_CREATE = *libstdfc::STDF_OPTS_CREATE;
*STDF_SETTING_WRITE_SIZE = *libstdfc::STDF_SETTING_WRITE_SIZE;
*STDF_SETTING_VERSION = *libstdfc::STDF_SETTING_VERSION;
*STDF_SETTING_BYTE_ORDER = *libstdfc::STDF_SETTING_BYTE_ORDER;
*REC_TYP_INFO = *libstdfc::REC_TYP_INFO;
*REC_TYP_PER_LOT = *libstdfc::REC_TYP_PER_LOT;
*REC_TYP_PER_WAFER = *libstdfc::REC_TYP_PER_WAFER;
*REC_TYP_PER_PART = *libstdfc::REC_TYP_PER_PART;
*REC_TYP_PER_TEST = *libstdfc::REC_TYP_PER_TEST;
*REC_TYP_PER_EXEC = *libstdfc::REC_TYP_PER_EXEC;
*REC_TYP_PER_PROG = *libstdfc::REC_TYP_PER_PROG;
*REC_TYP_PER_SITE = *libstdfc::REC_TYP_PER_SITE;
*REC_TYP_GENERIC = *libstdfc::REC_TYP_GENERIC;
*REC_TYP_RESV_IMAGE = *libstdfc::REC_TYP_RESV_IMAGE;
*REC_TYP_RESV_IG900 = *libstdfc::REC_TYP_RESV_IG900;
*REC_TYP_UNKNOWN = *libstdfc::REC_TYP_UNKNOWN;
*REC_SUB_FAR = *libstdfc::REC_SUB_FAR;
*REC_SUB_ATR = *libstdfc::REC_SUB_ATR;
*REC_SUB_MIR = *libstdfc::REC_SUB_MIR;
*REC_SUB_MRR = *libstdfc::REC_SUB_MRR;
*REC_SUB_PCR = *libstdfc::REC_SUB_PCR;
*REC_SUB_HBR = *libstdfc::REC_SUB_HBR;
*REC_SUB_SBR = *libstdfc::REC_SUB_SBR;
*REC_SUB_PMR = *libstdfc::REC_SUB_PMR;
*REC_SUB_PGR = *libstdfc::REC_SUB_PGR;
*REC_SUB_PLR = *libstdfc::REC_SUB_PLR;
*REC_SUB_RDR = *libstdfc::REC_SUB_RDR;
*REC_SUB_SDR = *libstdfc::REC_SUB_SDR;
*REC_SUB_WIR = *libstdfc::REC_SUB_WIR;
*REC_SUB_WRR = *libstdfc::REC_SUB_WRR;
*REC_SUB_WCR = *libstdfc::REC_SUB_WCR;
*REC_SUB_PIR = *libstdfc::REC_SUB_PIR;
*REC_SUB_PRR = *libstdfc::REC_SUB_PRR;
*REC_SUB_TSR = *libstdfc::REC_SUB_TSR;
*REC_SUB_PTR = *libstdfc::REC_SUB_PTR;
*REC_SUB_MPR = *libstdfc::REC_SUB_MPR;
*REC_SUB_FTR = *libstdfc::REC_SUB_FTR;
*REC_SUB_BPS = *libstdfc::REC_SUB_BPS;
*REC_SUB_EPS = *libstdfc::REC_SUB_EPS;
*REC_SUB_GDR = *libstdfc::REC_SUB_GDR;
*REC_SUB_DTR = *libstdfc::REC_SUB_DTR;
*REC_SUB_UNKNOWN = *libstdfc::REC_SUB_UNKNOWN;
*REC_STATE_RAW = *libstdfc::REC_STATE_RAW;
*REC_STATE_PARSED = *libstdfc::REC_STATE_PARSED;
*CPU_TYPE_DEC = *libstdfc::CPU_TYPE_DEC;
*CPU_TYPE_SPARC = *libstdfc::CPU_TYPE_SPARC;
*CPU_TYPE_X86 = *libstdfc::CPU_TYPE_X86;
*CPU_TYPE_UNKNOWN = *libstdfc::CPU_TYPE_UNKNOWN;
*MODE_AEL = *libstdfc::MODE_AEL;
*MODE_CHECKER = *libstdfc::MODE_CHECKER;
*MODE_DEBUG = *libstdfc::MODE_DEBUG;
*MODE_ENG = *libstdfc::MODE_ENG;
*MODE_MAINTENANCE = *libstdfc::MODE_MAINTENANCE;
*MODE_PRODUCTION = *libstdfc::MODE_PRODUCTION;
*MODE_QUALITY = *libstdfc::MODE_QUALITY;
*RETEST_YES = *libstdfc::RETEST_YES;
*RETEST_NO = *libstdfc::RETEST_NO;
*RETEST_UNKNOWN = *libstdfc::RETEST_UNKNOWN;
*BIN_PASS = *libstdfc::BIN_PASS;
*BIN_FAIL = *libstdfc::BIN_FAIL;
*BIN_UNKNOWN = *libstdfc::BIN_UNKNOWN;
*PIN_GRP_UNKNOWN = *libstdfc::PIN_GRP_UNKNOWN;
*PIN_GRP_NORMAL = *libstdfc::PIN_GRP_NORMAL;
*PIN_GRP_SCIO = *libstdfc::PIN_GRP_SCIO;
*PIN_GRP_SCIO_MID = *libstdfc::PIN_GRP_SCIO_MID;
*PIN_GRP_SCIO_VALID = *libstdfc::PIN_GRP_SCIO_VALID;
*PIN_GRP_SCIO_SUS = *libstdfc::PIN_GRP_SCIO_SUS;
*PIN_GRP_DUAL = *libstdfc::PIN_GRP_DUAL;
*PIN_GRP_DUAL_MID = *libstdfc::PIN_GRP_DUAL_MID;
*PIN_GRP_DUAL_VALID = *libstdfc::PIN_GRP_DUAL_VALID;
*PIN_GRP_DUAL_SUS = *libstdfc::PIN_GRP_DUAL_SUS;
*RADIX_DEFAULT = *libstdfc::RADIX_DEFAULT;
*RADIX_BINARY = *libstdfc::RADIX_BINARY;
*RADIX_OCTAL = *libstdfc::RADIX_OCTAL;
*RADIX_DECIMAL = *libstdfc::RADIX_DECIMAL;
*RADIX_HEX = *libstdfc::RADIX_HEX;
*RADIX_SYMBOLIC = *libstdfc::RADIX_SYMBOLIC;
*UNIT_UNKNOWN = *libstdfc::UNIT_UNKNOWN;
*UNIT_INCHES = *libstdfc::UNIT_INCHES;
*UNIT_CENTIMETERS = *libstdfc::UNIT_CENTIMETERS;
*UNIT_MILLIMETERS = *libstdfc::UNIT_MILLIMETERS;
*UNIT_MILS = *libstdfc::UNIT_MILS;
*FLAT_UP = *libstdfc::FLAT_UP;
*FLAT_DOWN = *libstdfc::FLAT_DOWN;
*FLAT_LEFT = *libstdfc::FLAT_LEFT;
*FLAT_RIGHT = *libstdfc::FLAT_RIGHT;
*FLAT_UNKNOWN = *libstdfc::FLAT_UNKNOWN;
*POS_LEFT = *libstdfc::POS_LEFT;
*POS_RIGHT = *libstdfc::POS_RIGHT;
*POS_UNKNOWN = *libstdfc::POS_UNKNOWN;
*POS_UP = *libstdfc::POS_UP;
*POS_DOWN = *libstdfc::POS_DOWN;
*PART_NEW_ID = *libstdfc::PART_NEW_ID;
*PART_NEW_COORD = *libstdfc::PART_NEW_COORD;
*PART_TEST_ABORTED = *libstdfc::PART_TEST_ABORTED;
*PART_FAILED = *libstdfc::PART_FAILED;
*PART_NO_INDICATION = *libstdfc::PART_NO_INDICATION;
*TEST_PARAMETRIC = *libstdfc::TEST_PARAMETRIC;
*TEST_FUNCTIONAL = *libstdfc::TEST_FUNCTIONAL;
*TEST_MULTIPLE = *libstdfc::TEST_MULTIPLE;
*TEST_UNKNOWN = *libstdfc::TEST_UNKNOWN;
*TEST_MIN_INVALID = *libstdfc::TEST_MIN_INVALID;
*TEST_MAX_INVALID = *libstdfc::TEST_MAX_INVALID;
*TEST_TIM_INVALID = *libstdfc::TEST_TIM_INVALID;
*TEST_SUMS_INVALID = *libstdfc::TEST_SUMS_INVALID;
*TEST_SQRS_INVALID = *libstdfc::TEST_SQRS_INVALID;
*GDR_B0 = *libstdfc::GDR_B0;
*GDR_U1 = *libstdfc::GDR_U1;
*GDR_U2 = *libstdfc::GDR_U2;
*GDR_U4 = *libstdfc::GDR_U4;
*GDR_I1 = *libstdfc::GDR_I1;
*GDR_I2 = *libstdfc::GDR_I2;
*GDR_I4 = *libstdfc::GDR_I4;
*GDR_R4 = *libstdfc::GDR_R4;
*GDR_R8 = *libstdfc::GDR_R8;
*GDR_Cn = *libstdfc::GDR_Cn;
*GDR_Bn = *libstdfc::GDR_Bn;
*GDR_Dn = *libstdfc::GDR_Dn;
*GDR_N1 = *libstdfc::GDR_N1;
1;
